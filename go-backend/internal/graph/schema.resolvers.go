package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"time"

	"github.com/augustdev/autoclip/internal/authz"
	model1 "github.com/augustdev/autoclip/internal/graph/model"
)

// CreateAPIKey is the resolver for the createAPIKey field.
func (r *mutationResolver) CreateAPIKey(ctx context.Context, name string) (*model1.CreateAPIKeyResult, error) {
	result, err := r.AuthService.GenerateAPIKey(ctx, authz.For(ctx).GetUserID(), name)
	if err != nil {
		return nil, fmt.Errorf("failed to create API key: %w", err)
	}

	return &model1.CreateAPIKeyResult{
		APIKey: &model1.APIKey{
			ID:        result.ID,
			Name:      result.Name,
			Prefix:    result.Prefix,
			CreatedAt: result.CreatedAt,
		},
		Secret: result.FullKey,
	}, nil
}

// RevokeAPIKey is the resolver for the revokeAPIKey field.
func (r *mutationResolver) RevokeAPIKey(ctx context.Context, id string) (bool, error) {
	if err := r.AuthService.RevokeAPIKey(ctx, authz.For(ctx).GetUserID(), id); err != nil {
		return false, fmt.Errorf("failed to revoke API key: %w", err)
	}

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model1.User, error) {
	user, err := r.AuthService.GetUserByID(ctx, authz.For(ctx).GetUserID())
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	var avatarURL *string
	if user.AvatarUrl.Valid {
		avatarURL = &user.AvatarUrl.String
	}

	return &model1.User{
		ID:             user.ID,
		GithubUsername: user.GithubUsername,
		AvatarURL:      avatarURL,
		CreatedAt:      user.CreatedAt.Time,
	}, nil
}

// MyAPIKeys is the resolver for the myAPIKeys field.
func (r *queryResolver) MyAPIKeys(ctx context.Context) ([]*model1.APIKey, error) {
	keys, err := r.AuthService.ListAPIKeys(ctx, authz.For(ctx).GetUserID())
	if err != nil {
		return nil, fmt.Errorf("failed to list API keys: %w", err)
	}

	result := make([]*model1.APIKey, len(keys))
	for i, key := range keys {
		var lastUsedAt *time.Time
		if key.LastUsedAt.Valid {
			t := key.LastUsedAt.Time
			lastUsedAt = &t
		}

		result[i] = &model1.APIKey{
			ID:         key.ID,
			Name:       key.Name,
			Prefix:     key.KeyPrefix,
			LastUsedAt: lastUsedAt,
			CreatedAt:  key.CreatedAt.Time,
		}
	}

	return result, nil
}

// HasGithubAppInstalled is the resolver for the hasGithubAppInstalled field.
func (r *userResolver) HasGithubAppInstalled(ctx context.Context, obj *model1.User) (bool, error) {
	userID := authz.For(ctx).GetUserID()

	// Get user from database to check current installation status
	user, err := r.AuthService.GetUserByID(ctx, userID)
	if err != nil {
		return false, fmt.Errorf("failed to get user: %w", err)
	}

	// If we already have an installation ID cached, return true
	if user.GithubAppInstallationID.Valid {
		return true, nil
	}

	// Check with GitHub API if the user has installed the app
	installationID, err := r.GitHubAppService.GetUserInstallation(ctx, user.GithubUsername)
	if err != nil {
		r.Logger.Error("failed to check GitHub App installation", "error", err, "username", user.GithubUsername)
		return false, nil // Return false on error, don't block the user
	}

	if installationID == 0 {
		// User has not installed the app
		return false, nil
	}

	// User has installed the app, cache the installation ID in the database
	err = r.AuthService.SetGitHubAppInstallation(ctx, userID, installationID)
	if err != nil {
		r.Logger.Error("failed to save GitHub App installation ID", "error", err)
		// Still return true since the app is installed
	}

	return true, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
